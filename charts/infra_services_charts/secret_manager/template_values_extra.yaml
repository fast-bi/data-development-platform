## Fast.BI Deployment 
# Helm deployment values for Service.
# Helm Chart name: {{ chart_name }}
# Helm Chart repo: {{ chart_repo }}
# Helm Chart version {{ chart_version }}
#
# vault-operator.yaml
{% raw %}
apiVersion: batch/v1
kind: CronJob
metadata:
  name: vault-operator
  namespace: vault
spec:
  schedule: "*/5 * * * *"
  successfulJobsHistoryLimit: 1
  failedJobsHistoryLimit: 1
  concurrencyPolicy: Forbid
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: vault-operator
          containers:
            - name: vault-operator
              image: bitnamilegacy/kubectl:1.33.4
              command: ["/bin/bash", "-c"]
              args:
                - |
                  # Function to check if pod is running and ready
                  check_pod_ready() {
                    kubectl get pod vault-0 -n vault -o jsonpath='{.status.containerStatuses[0].started}' | grep -q "true"
                  }

                  # Function to check if vault responds to status
                  check_vault_responding() {
                    STATUS_OUTPUT=$(kubectl exec -n vault vault-0 -- vault status -format=json 2>/dev/null)
                    if [ $? -eq 2 ]; then
                      # Exit code 2 means vault is responding but not initialized - this is okay
                      return 0
                    elif [ -n "$STATUS_OUTPUT" ]; then
                      # We got some output, vault is responding
                      return 0
                    else
                      # No output, vault is not responding
                      return 1
                    fi
                  }

                  echo "Waiting for vault-0 pod to exist and be ready..."
                  while ! check_pod_ready; do
                    echo "Pod not ready yet, waiting..."
                    sleep 5
                  done

                  echo "Pod is ready, checking Vault status..."
                  RETRY_COUNT=0
                  MAX_RETRIES=30  # 5 minutes with 10-second intervals
                  while ! check_vault_responding; do
                    RETRY_COUNT=$((RETRY_COUNT + 1))
                    if [ $RETRY_COUNT -ge $MAX_RETRIES ]; then
                      echo "Vault not responding after 5 minutes, exiting"
                      exit 1
                    fi
                    echo "Vault not responding yet, waiting... (Attempt $RETRY_COUNT/$MAX_RETRIES)"
                    sleep 10
                  done

                  echo "Vault is responding, checking initialization status..."
                  STATUS=$(kubectl exec -n vault vault-0 -- vault status -format=json)
                  INITIALIZED=$(echo $STATUS | jq -r '.initialized')
                  SEALED=$(echo $STATUS | jq -r '.sealed')

                  if [ "$INITIALIZED" = "false" ]; then
                    echo "Vault is not initialized. Initializing..."
                    INIT_RESPONSE=$(kubectl exec -n vault vault-0 -- vault operator init -key-shares=1 -key-threshold=1 -format=json)

                    # Store the unseal key and root token
                    UNSEAL_KEY=$(echo "$INIT_RESPONSE" | jq -r '.unseal_keys_b64[0]')
                    ROOT_TOKEN=$(echo "$INIT_RESPONSE" | jq -r '.root_token')

                    # Create Kubernetes secret
                    kubectl create secret generic vault-init \
                      --from-literal=unseal-key="$UNSEAL_KEY" \
                      --from-literal=root-token="$ROOT_TOKEN" \
                      -n vault

                    echo "Unsealing vault..."
                    kubectl exec -n vault vault-0 -- vault operator unseal "$UNSEAL_KEY"

                    # Configure Vault with auth methods and secrets engines
                    echo "Configuring Vault..."
                    kubectl exec -n vault vault-0 -- sh -c "
                      export VAULT_TOKEN='$ROOT_TOKEN'
                      vault auth enable kubernetes
                      vault write auth/kubernetes/config \
                        kubernetes_host='https://\$KUBERNETES_PORT_443_TCP_ADDR:443' \
                        token_reviewer_jwt='\$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)' \
                        kubernetes_ca_cert='\$(cat /var/run/secrets/kubernetes.io/serviceaccount/ca.crt)'

                      vault policy write app - <<EOF
                      path \"secret/data/*\" {
                        capabilities = [\"read\", \"list\"]
                      }
                      EOF

                      vault secrets enable -version=2 -path=secret kv
                    "
                  elif [ "$SEALED" = "true" ]; then
                    echo "Vault is sealed. Unsealing..."
                    UNSEAL_KEY=$(kubectl get secret vault-init -n vault -o jsonpath='{.data.unseal-key}' | base64 -d)
                    kubectl exec -n vault vault-0 -- vault operator unseal "$UNSEAL_KEY"
                  else
                    echo "Vault is initialized and unsealed"
                  fi
          restartPolicy: OnFailure

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: vault-operator
  namespace: vault

---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: vault-operator
  namespace: vault
rules:
  - apiGroups: [""]
    resources: ["pods", "secrets"]
    verbs: ["get", "list", "create", "update"]
  - apiGroups: [""]
    resources: ["pods/exec"]
    verbs: ["create"]
  - apiGroups: ["batch"]
    resources: ["jobs", "cronjobs"]
    verbs: ["get", "list", "create", "update", "delete", "watch"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: vault-operator
  namespace: vault
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: vault-operator
subjects:
  - kind: ServiceAccount
    name: vault-operator
    namespace: vault

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: vault-populator-policy
  namespace: vault
data:
  policy.hcl: |
    # Enable managing the KV secrets engine
    path "sys/mounts/*" {
      capabilities = ["create", "read", "update", "delete", "list"]
    }

    # Enable managing secrets under the KV store
    path "secret/*" {
      capabilities = ["create", "read", "update", "delete", "list"]
    }

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: vault-populator
  namespace: vault

---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: vault-populator
  namespace: vault
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "list"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: vault-populator
  namespace: vault
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: vault-populator
subjects:
  - kind: ServiceAccount
    name: vault-populator
    namespace: vault

---
apiVersion: batch/v1
kind: Job
metadata:
  name: vault-auth-config
  namespace: vault
spec:
  backoffLimit: 6
  template:
    spec:
      serviceAccountName: vault-operator
      containers:
        - name: vault-auth-config
          image: bitnamilegacy/kubectl:1.33.4
          command: ["/bin/bash", "-c"]
          args:
            - |
              # Trigger the initialization cronjob.
              kubectl create job --from=cronjob/vault-operator vault-operator-manual-trigger

              # Wait for vault-0 pod to exist and be ready
              until kubectl get pod vault-0 -n vault >/dev/null 2>&1; do
                echo "Waiting for vault-0 pod to exist..."
                sleep 5
              done

              # Wait for Vault to be unsealed
              until kubectl exec -n vault vault-0 -- vault status >/dev/null 2>&1; do
                echo "Waiting for Vault to be ready..."
                sleep 5
              done

              # Get root token from secret
              ROOT_TOKEN=$(kubectl get secret vault-init -n vault -o jsonpath='{.data.root-token}' | base64 -d)

              # Enable kubernetes auth if not already enabled
              if ! kubectl exec -n vault vault-0 -- sh -c "VAULT_TOKEN=$ROOT_TOKEN vault auth list" | grep -q kubernetes/; then
                echo "Enabling Kubernetes auth..."
                kubectl exec -n vault vault-0 -- sh -c "VAULT_TOKEN=$ROOT_TOKEN vault auth enable kubernetes"
              fi

              # Get service account token and CA cert
              SA_JWT=$(kubectl exec -n vault vault-0 -- cat /var/run/secrets/kubernetes.io/serviceaccount/token)
              SA_CA_CRT=$(kubectl exec -n vault vault-0 -- cat /var/run/secrets/kubernetes.io/serviceaccount/ca.crt | base64 -w0)

              # Configure Kubernetes auth
              kubectl exec -n vault vault-0 -- sh -c "VAULT_TOKEN=$ROOT_TOKEN vault write auth/kubernetes/config \
                kubernetes_host='https://kubernetes.default.svc:443' \
                kubernetes_ca_cert_base64='${SA_CA_CRT}' \
                token_reviewer_jwt='${SA_JWT}' \
                issuer='https://kubernetes.default.svc.cluster.local'"

              # Create policy for populator with updated sys/mounts permissions
              kubectl exec -n vault vault-0 -- sh -c "VAULT_TOKEN=$ROOT_TOKEN vault policy write vault-populator - <<EOF
              # Enable reading mounts
              path \"sys/mounts\" {
                capabilities = [\"read\", \"list\"]
              }

              # Enable managing mounts
              path \"sys/mounts/*\" {
                capabilities = [\"create\", \"read\", \"update\", \"delete\", \"list\"]
              }

              # Enable managing secrets under the KV store
              path \"secret/*\" {
                capabilities = [\"create\", \"read\", \"update\", \"delete\", \"list\"]
              }

              # Enable managing secrets engine configuration
              path \"sys/mounts/secret/tune\" {
                capabilities = [\"create\", \"read\", \"update\", \"delete\", \"list\"]
              }

              # Allow checking capabilities
              path \"sys/capabilities*\" {
                capabilities = [\"create\", \"update\"]
              }
              EOF"

              # Create Kubernetes auth role
              kubectl exec -n vault vault-0 -- sh -c "VAULT_TOKEN=$ROOT_TOKEN vault write auth/kubernetes/role/vault-populator \
                bound_service_account_names=vault-populator \
                bound_service_account_namespaces=vault \
                policies=vault-populator \
                ttl=1h"
      restartPolicy: OnFailure

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: vault-populator
  namespace: vault

---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: vault-populator
  namespace: vault
rules:
  - apiGroups: [""]
    resources: ["pods", "pods/exec"]
    verbs: ["get", "list", "watch", "create"]
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "list"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: vault-populator
  namespace: vault
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: vault-populator
subjects:
  - kind: ServiceAccount
    name: vault-populator
    namespace: vault

---
apiVersion: batch/v1
kind: Job
metadata:
  name: vault-populator
  namespace: vault
spec:
  backoffLimit: 6
  template:
    spec:
      serviceAccountName: vault-populator
      initContainers:
        - name: wait-for-auth
          image: bitnamilegacy/kubectl:1.33.4
          command: ["/bin/bash", "-c"]
          args:
            - |
              # Wait for vault-0 pod to exist and be ready
              until kubectl get pod vault-0 -n vault >/dev/null 2>&1; do
                echo "Waiting for vault-0 pod to exist..."
                sleep 5
              done

              # Wait for Vault to be unsealed
              until kubectl exec -n vault vault-0 -- vault status >/dev/null 2>&1; do
                echo "Waiting for Vault to be ready..."
                sleep 5
              done

              # Wait for auth role to be created
              ROOT_TOKEN=$(kubectl get secret vault-init -n vault -o jsonpath='{.data.root-token}' | base64 -d)
              until kubectl exec -n vault vault-0 -- sh -c "VAULT_TOKEN=$ROOT_TOKEN vault read auth/kubernetes/role/vault-populator" >/dev/null 2>&1; do
                echo "Waiting for Vault auth role to be configured..."
                sleep 5
              done
      containers:
        - name: vault-populator
          image: python:3.9-slim
          command: ["/bin/bash", "-c"]
          args:
            - |
              pip install hvac &&
              python /app/populate_vault.py
          env:
            - name: VAULT_ADDR
              value: "http://vault:8200"
            - name: VAULT_ROLE
              value: "vault-populator"
            - name: VAULT_MOUNT_POINT
              value: "secret"
            - name: SECRETS_FILE
              value: "/secrets/vault-secrets.json"
          volumeMounts:
            - name: app-code
              mountPath: /app
            - name: secrets
              mountPath: /secrets
              readOnly: true
      volumes:
        - name: app-code
          configMap:
            name: vault-populator-script
        - name: secrets
          secret:
            secretName: vault-secrets
      restartPolicy: Never

---
# Store the Python script in a ConfigMap
apiVersion: v1
kind: ConfigMap
metadata:
  name: vault-populator-script
  namespace: vault
data:
  populate_vault.py: |
    #!/usr/bin/env python3
    import hvac
    import json
    import os
    import logging
    import sys
    from typing import Dict, Any, List
    import time
    from pathlib import Path

    # Configure logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    logger = logging.getLogger(__name__)

    class VaultPopulator:
        def __init__(self, vault_addr: str, mount_point: str = "secret"):
            """
            Initialize the VaultPopulator with connection details.
            
            Args:
                vault_addr: The address of the Vault server
                mount_point: The mount point for the KV secrets engine (default: "secret")
            """
            self.vault_addr = vault_addr
            self.mount_point = mount_point
            self.client = None
            
        def connect_with_k8s(self, role: str, jwt_path: str = '/var/run/secrets/kubernetes.io/serviceaccount/token') -> None:
            """
            Connect to Vault using Kubernetes authentication.
            
            Args:
                role: The Vault role to authenticate with
                jwt_path: Path to the JWT token file
            """
            try:
                # Read the JWT token
                with open(jwt_path, 'r') as f:
                    jwt = f.read()

                # Create Vault client
                self.client = hvac.Client(url=self.vault_addr)
                
                # Authenticate with Kubernetes
                auth_response = self.client.auth.kubernetes.login(
                    role=role,
                    jwt=jwt
                )
                
                logger.info("Successfully authenticated to Vault using Kubernetes auth")
                
                # Verify client is authenticated
                if not self.client.is_authenticated():
                    raise Exception("Failed to authenticate with Vault")
                    
            except Exception as e:
                logger.error(f"Failed to connect to Vault: {str(e)}")
                raise

        def ensure_kv_enabled(self) -> None:
            """
            Ensure the KV secrets engine is enabled at the specified mount point.
            """
            try:
                # Check if KV is already enabled
                mounts = self.client.sys.list_mounted_secrets_engines()
                if f"{self.mount_point}/" not in mounts:
                    # Enable KV secrets engine version 2
                    self.client.sys.enable_secrets_engine(
                        backend_type='kv',
                        path=self.mount_point,
                        options={'version': '2'}
                    )
                    logger.info(f"Enabled KV secrets engine at {self.mount_point}")
                else:
                    logger.info(f"KV secrets engine already enabled at {self.mount_point}")
                    
            except Exception as e:
                logger.error(f"Failed to ensure KV secrets engine: {str(e)}")
                raise

        def create_folder_structure(self, structure: Dict[str, Any], parent_path: str = "") -> None:
            """
            Create the folder structure in Vault based on the provided structure.
            
            Args:
                structure: Dictionary representing the folder structure
                parent_path: Current path in the hierarchy
            """
            try:
                for key, value in structure.items():
                    current_path = f"{parent_path}/{key}" if parent_path else key
                    
                    if isinstance(value, dict):
                        # If all values in the dict are strings or None, it's a secrets directory
                        if all(isinstance(v, (str, type(None))) for v in value.values()):
                            # Store the secrets
                            secrets_path = current_path.lstrip('/')
                            self.store_secrets(secrets_path, value)
                        else:
                            # Recurse into the directory
                            self.create_folder_structure(value, current_path)
                            
            except Exception as e:
                logger.error(f"Failed to create folder structure at {parent_path}: {str(e)}")
                raise

        def store_secrets(self, path: str, secrets: Dict[str, str]) -> None:
            """
            Store secrets at the specified path.
            
            Args:
                path: Path where to store the secrets
                secrets: Dictionary of secrets to store
            """
            try:
                # Filter out None values and convert all values to strings
                cleaned_secrets = {k: str(v if v is not None else "") for k, v in secrets.items()}
                
                # Store secrets
                self.client.secrets.kv.v2.create_or_update_secret(
                    path=path,
                    secret=cleaned_secrets,
                    mount_point=self.mount_point
                )
                
                logger.info(f"Stored secrets at {path}")
                
            except Exception as e:
                logger.error(f"Failed to store secrets at {path}: {str(e)}")
                raise

        def populate_from_file(self, file_path: str) -> None:
            """
            Populate Vault with secrets from a file.
            
            Args:
                file_path: Path to the JSON file containing secrets
            """
            try:
                # Read the secrets file
                with open(file_path, 'r') as f:
                    structure = json.load(f)
                
                # Ensure KV is enabled
                self.ensure_kv_enabled()
                
                # Create structure and populate secrets
                self.create_folder_structure(structure)
                
                logger.info("Successfully populated Vault with secrets from file")
                
            except Exception as e:
                logger.error(f"Failed to populate Vault from file: {str(e)}")
                raise

    def main():
        # Get configuration from environment
        vault_addr = os.getenv('VAULT_ADDR', 'http://vault:8200')
        vault_role = os.getenv('VAULT_ROLE', 'vault-populator')
        secrets_file = os.getenv('SECRETS_FILE', '/secrets/vault-secrets.json')
        mount_point = os.getenv('VAULT_MOUNT_POINT', 'secret')
        
        # Maximum number of retries
        max_retries = 5
        retry_delay = 10  # seconds
        
        for attempt in range(max_retries):
            try:
                # Initialize populator
                populator = VaultPopulator(vault_addr, mount_point)
                
                # Connect to Vault
                populator.connect_with_k8s(vault_role)
                
                # Populate secrets
                populator.populate_from_file(secrets_file)
                
                logger.info("Secret population completed successfully")
                break
                
            except Exception as e:
                if attempt < max_retries - 1:
                    logger.warning(f"Attempt {attempt + 1} failed: {str(e)}. Retrying in {retry_delay} seconds...")
                    time.sleep(retry_delay)
                else:
                    logger.error(f"Failed to populate secrets after {max_retries} attempts")
                    raise

    if __name__ == "__main__":
        main()
{%endraw%}